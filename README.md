# 
# Web Server Design: CS531
#

# Methods Implemented:
* GET
* HEAD
* OPTIONS
* TRACE

# Status Codes Implemented

* 200 - OK
* 400 - Bad Request
* 403 - Forbidden
* 404 - Not Found
* 500 - Internal Server Error
* 501 - Not Implemented
* 505 - HTTP Version Not Supported
* 301 Moved Permanently
if “/foo” is a directory, the server should 301 redirect to “/foo/”
* 302 Found
takes a configurable list of regular expressions and provides URIs that the server should 302 redirect to
* 304 Not Modified
* 408 Request Timeout
* 412 Precondition Failed
* 206 Partial Content
* 300 Multiple Choice
use if there are > 1 possible representations and 1) UA sends Negotiate: 1.0 or 2) qvalues result in a tie
* 406 Not Acceptable
use if there are no possible representations that match the requested q values
* 416 Requested Range Not Satisfiable
# Request Headers

* Host:
* Connection: close
is now optional; its absence means the request is long-lived
* If-Modified-Since
* If-Unmodified-Since
* If-Match
* If-None-Match
* Accept
* Accept-Charset
* Accept-Encoding
* Accept-Language
* Negotiate
* Range
We will defer multiple Range specifications that would result in a “multipart/byteranges” response (sections 4.1, 4.3)
* If-Range
* User-Agent
* Referer
# Response Headers
* Date
* Server
* Last-Modified
* Content-Length
* Content-Type
* Connection: close
* Allow
* ETag
* Location
* Content-Language
* Content-Location
* Content-Encoding
“Transfer-Encoding: chunked”
Revisit Section 7.1, RFC 7230 for the correct syntax
* Alternates
* TCN
* Accept-Range
* Content-Range
* Content-type
add charset after type if not ISO-8859-1 (ASCII); see week 9 slides for examples
* Encodings
supports “gzip” and “compress”
Use “chunked” transfer encoding for any dynamically generated server response
i.e., directory listings and 3xx, 4xx, 5xx html snippets
use 2 lines as the “chunk”
# MIME Types Supported:

* text/plain
* text/html
* text/xml
* image/png
* image/jpeg
* image/gif
* application/pdf
* application/vnd.ms-powerpoint
* application/vnd.ms-word
* message/http
* application/octet-stream (default mime type)

# Access Log Implemented:

* GET /.well-known/access.log HTTP/1.1
cf. RFC 5785
(typically not a good idea to expose your log via the web server, but ok for this project)
implement as a virtual URI
* Content-type will be “text/plain”

# Notes

* Support both long-lived and pipelined connections
* Use a default of 15 seconds for timeouts (specify in a config file)
* Only compute “strong” ETags (come up with your own method)
* Any GET method that does not result in a 20X response code MUST have a text/html entity generated by the server explaining the response code (unless prohibited, like 304)
* in a config file, specify that index.html is the default resource name for when a URI ends in “/”
* if a directory does not have a default resource (i.e., index.html), then dynamically generate an HTML listing of the directories files (they should be clickable, with dates, sizes, etc.)
* create a separate config file that supports redirections of the form:
 ```
Status: Incoming RE Redirect URI 
302: ^(.*)/coolcar.html$ $1/galaxie.html 
302: ^(.*)/1.[234]/(.*) $1/1.1/$2 
301: ^(.*)/mercury/(.*)$ $1/ford/$2
```
* Support/advertise partial GET capability (i.e., Accept-Range) for all resources for all resources/responses for which you don’t use Transfer-Encoding: chunked
* Use these language encodings (in a config file):
en, es, de, ja, ko, ru
* Use these non-ASCII charset encodings (in a config file):
“.jis” -> “iso-2022-jp”
“koi8-r” -> “koi8-r”
“euc-kr” -> “euc-kr”
* Build “Vary” response header as:
Vary: negotiate, header1, header2, …, headerN
only send Vary if CN is possible for this URI
* Generate structured ETags on selected representation as per RFC 2295 (section 9.2)
